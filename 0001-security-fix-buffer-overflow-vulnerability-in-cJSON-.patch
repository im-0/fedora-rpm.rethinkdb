From 691834a30e5d8bfc0abd89e0ab7f65258f419240 Mon Sep 17 00:00:00 2001
From: Yan Naing Tun <yannaingtun2007@gmail.com>
Date: Mon, 30 Jun 2025 19:48:20 +0800
Subject: [PATCH] security: fix buffer overflow vulnerability in cJSON string
 parsing (#7163)

This commit fixes a buffer overflow vulnerability (CVE-2016-4303) in the
cJSON string parsing function. The issue occurs when parsing UTF-16 surrogate
pairs in JSON strings, where the buffer allocated may not be large enough
to handle the converted UTF-8 characters.

The fix adds proper bounds checking, improved error handling, and unicode
validation similar to the original cJSON library patch. This prevents
potential heap corruption and arbitrary code execution.

Discovered and originally reported by Dave McDaniel, Cisco Talos.
---
 src/cjson/cJSON.cc | 72 +++++++++++++++++++++++++++++-----------------
 1 file changed, 45 insertions(+), 27 deletions(-)

diff --git a/src/cjson/cJSON.cc b/src/cjson/cJSON.cc
index 781b05d9f4c2..341206c860f8 100644
--- a/src/cjson/cJSON.cc
+++ b/src/cjson/cJSON.cc
@@ -217,34 +217,42 @@ static unsigned parse_hex4(const char *str)
 /* Parse the input text into an unescaped cstring, and populate item. */
 static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
 
-static const char *parse_string(cJSON *item,const char *str)
+static const char *parse_string(cJSON *item, const char *str)
 {
     const char *ptr = str+1;
+    const char *end_ptr = str+1;
     char *ptr2;
     char *out;
     int len = 0;
     unsigned uc, uc2;
-
+    
     if (*str != '\"') {
         // Not a string.
         ep = str;
         return 0;
     }
-
-    while (*ptr != '\"' && *ptr && ++len) {
-        // Skip escaped quotes.
-        if (*ptr++ == '\\') ptr++;
+    
+    // Calculate approximate length first
+    while (*end_ptr != '\"' && *end_ptr && ++len) {
+        if (*end_ptr++ == '\\') end_ptr++;  // Skip escaped quotes.
     }
-
+    
     // This is how long we need for the string, roughly.
-    out=(char*)cJSON_malloc(len+1);
+    out = (char*)cJSON_malloc(len+1);
     if (!out) {
         return 0;
     }
-
-    ptr=str+1;
-    ptr2=out;
-    while (*ptr != '\"' && *ptr) {
+    
+    // Set these values early so memory will be properly cleaned up in error cases
+    item->valuestring = out;
+    item->type = cJSON_String;
+    
+    ptr = str+1;
+    ptr2 = out;
+    
+    // Use end_ptr for bounds checking
+    while (ptr < end_ptr)
+    {
         if (*ptr != '\\') {
             *ptr2++ = *ptr++;
         } else {
@@ -257,31 +265,45 @@ static const char *parse_string(cJSON *item,const char *str)
                 case 'r': *ptr2++ = '\r'; break;
                 case 't': *ptr2++ = '\t'; break;
                 case 'u': /* transcode utf16 to utf8. */
-                    /* get the unicode char. */
+                    // Get the unicode char.
                     uc = parse_hex4(ptr+1);
                     ptr += 4;
-
+                    
+                    // Bounds check
+                    if (ptr >= end_ptr) {
+                        ep = str;
+                        return 0;  // Invalid
+                    }
+                    
                     // Fail on invalid Unicode characters, unlike normal cJSON.
                     if ((uc >= 0xDC00 && uc <= 0xDFFF) || uc == 0) {
-                        cJSON_free(out);
+                        ep = str;
                         return 0;
                     }
-
+                    
                     if (uc >= 0xD800 && uc <= 0xDBFF) {
-                        /* UTF16 surrogate pairs. */
+                        // UTF16 surrogate pairs.
+                        if (ptr+6 > end_ptr) {
+                            ep = str;
+                            return 0;  // Invalid
+                        }
+                        
                         if (ptr[1] != '\\' || ptr[2] != 'u') {
-                            /* missing second-half of surrogate. */
+                            // Missing second-half of surrogate.
                             break;
                         }
+                        
                         uc2 = parse_hex4(ptr + 3);
                         ptr += 6;
+                        
                         if (uc2 < 0xDC00 || uc2 > 0xDFFF) {
-                            break;	/* invalid second-half of surrogate. */
+                            break; // Invalid second-half of surrogate.
                         }
+                        
                         uc = 0x10000 + (((uc & 0x3FF) << 10) | (uc2 & 0x3FF));
                     }
-
-                    len=4;
+                    
+                    len = 4;
                     if (uc < 0x80) {
                         len = 1;
                     } else if (uc < 0x800) {
@@ -289,8 +311,8 @@ static const char *parse_string(cJSON *item,const char *str)
                     } else if (uc < 0x10000) {
                         len = 3;
                     }
+                    
                     ptr2 += len;
-
                     switch (len) {
                         case 4: *--ptr2 = ((uc | 0x80) & 0xBF); uc >>= 6;
                             // fallthrough
@@ -307,13 +329,9 @@ static const char *parse_string(cJSON *item,const char *str)
             ptr++;
         }
     }
-
+    
     *ptr2 = 0;
     if (*ptr == '\"') ptr++;
-
-    item->valuestring = out;
-    item->type = cJSON_String;
-
     return ptr;
 }
 
-- 
2.51.0

